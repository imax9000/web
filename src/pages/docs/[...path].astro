---
import type { GetStaticPathsResult } from "astro";
import {
	Application,
	type DeclarationReflection,
	ReflectionKind,
} from "typedoc";
import ClassPage from "../../templates/ClassPage.astro";

export async function getStaticPaths(): Promise<GetStaticPathsResult> {
	const app = await Application.bootstrap({
		entryPointStrategy: "packages",
		entryPoints: ["packages/*"],
	});
	const project = await app.convert();
	if (!project) throw new Error("Failed to generate documentation.");

	const modules = project.getChildrenByKind(ReflectionKind.Module);

	const pages: GetStaticPathsResult = [];

	for (const module of modules) {
		const packageSlug = module.name.split("/").pop();
		for (const reflection of module.children || []) {
			switch (reflection.kind) {
				case ReflectionKind.Class:
					pages.push({
						params: {
							path: `${packageSlug}/classes/${reflection.name}`,
						},
						props: { reflection },
					});
					break;
				case ReflectionKind.Interface:
				case ReflectionKind.TypeAlias:
					pages.push({
						params: {
							path: `${packageSlug}/types/${reflection.name}`,
						},
						props: { reflection },
					});
					break;
				case ReflectionKind.Enum:
					pages.push({
						params: {
							path: `${packageSlug}/enums/${reflection.name}`,
						},
						props: { reflection },
					});
					break;
				case ReflectionKind.Function:
					pages.push({
						params: {
							path: `${packageSlug}/functions/${reflection.name}`,
						},
						props: { reflection },
					});
					break;
				case ReflectionKind.Variable:
					pages.push({
						params: {
							path: `${packageSlug}/variables/${reflection.name}`,
						},
						props: { reflection },
					});
					break;
				default:
					break;
			}
		}
	}

	return pages;
}

const DocsTemplates = { [ReflectionKind.Class]: ClassPage };

interface Props {
	reflection: DeclarationReflection;
}

const { reflection } = Astro.props;

const Template = DocsTemplates[reflection.kind] || null;
---
{Template && <Template reflection={reflection} />}
