---
import type { GetStaticPathsResult } from "astro";
import {
	Application,
	type DeclarationReflection,
	ReflectionKind,
} from "typedoc";
import ClassPage from "../../templates/ClassPage.astro";
import EnumPage from "../../templates/EnumPage.astro";
import FunctionPage from "../../templates/FunctionPage.astro";
import TypePage from "../../templates/TypePage.astro";
import VariablePage from "../../templates/VariablePage.astro";
import { reflectionShouldBeRendered } from "../../util/reflectionShouldBeRendered";
import {
	externalSymbolLinkMappings,
	resolveReflectionUrl,
} from "../../util/resolveUrl";
import { serializeSources } from "../../util/typedocSerializeSources";

export async function getStaticPaths(): Promise<GetStaticPathsResult> {
	const app = await Application.bootstrap({
		entryPointStrategy: "packages",
		entryPoints: ["packages/*"],
		excludeExternals: true,
		excludeInternal: true,
		excludePrivate: true,
		excludeProtected: true,
		externalSymbolLinkMappings,
	});
	serializeSources(app);
	const project = await app.convert();
	if (!project) throw new Error("Failed to generate documentation.");

	const modules = project.getChildrenByKind(ReflectionKind.Module);

	const pages: GetStaticPathsResult = [];

	for (const module of modules) {
		for (const reflection of module.children) {
			if (!reflectionShouldBeRendered(reflection)) continue;

			const path = resolveReflectionUrl(reflection)?.replace(
				"/docs/",
				"",
			);
			if (!path) {
				throw new Error(`Failed to resolve URL for ${reflection.name}`);
			}
			if (
				reflection.kindOf([
					ReflectionKind.Class,
					ReflectionKind.Interface,
					ReflectionKind.TypeAlias,
					ReflectionKind.Enum,
					ReflectionKind.Function,
					ReflectionKind.Variable,
				])
			) {
				pages.push({ params: { path }, props: { reflection } });
			}
		}
	}

	return pages;
}

const DocsTemplates = {
	[ReflectionKind.Class]: ClassPage,
	[ReflectionKind.Interface]: TypePage,
	[ReflectionKind.TypeAlias]: TypePage,
	[ReflectionKind.Enum]: EnumPage,
	[ReflectionKind.Function]: FunctionPage,
	[ReflectionKind.Variable]: VariablePage,
};

interface Props {
	reflection: DeclarationReflection;
}

const { reflection } = Astro.props;

const Template = DocsTemplates[reflection.kind] || null;
---
{Template && <Template reflection={reflection} />}
